Software Testing Fundamentals

Software Development Lifecycle - SDLC - (entire application or single sprint)
1. Analysis of existing system
	- Identify areas of improvement, (what you have or similiar applications)
2. System requirements identified
	- Propose new features
	- Address existing issues/concerns
3. Proposed system is defined
	- Overall design is developed
	- Technology stack chosen
4. New system is developed
	- Actual coding/implementaion
5. Testing/Integration
	- Test your new feature(s)
	- Test for compatibility (everythign still works)
6. Maintenance/Monitoring
	- Report areas of deficiencies
	- Use this information to start a new cycle

Software Testing lifecycle - STLC
1. Planning/Analysis
	- What needs to be tested?
	- Is it testable?
		- What's in time and company's budget, scope problem
2. Design
	- How are we going to set up tests?
	- Automatic? What frameworks?
3. Develop you test cases
	- Write the code your tests
	- Unit and Integration tests
	- Find edge cases
	- Good test cases should not overlap or be redundant
	- However, more important that all functionality is covered
4. Choose an enviroment for your tests
	- What software/hardware are you running tests on? (OS?)
5. Test execution
	- Run tests
6. Conclusion/Wrap Up
	- Generate a report of the finding from the test execution
		- 100 passes, 3 failed, why did they failed?
		- Code coverage
	- Use this info in next cycle


Defect Lifecycle (Flow chart)

New		- Bug detected
Assigned	- Assigned to developer
Rejected	- Defect id thrown out for various reason, "it's not a defect"
Deferred	- Put off for various reason, like not that important rn, will be overwritten
Test/Fixed	- Test the cases and attempt to fix
Reassign	- Failed to fix. Might not have been assigned to a developer w appropriate skills (front/backend)
Verified	- Other developers/testers will verify it is fixed
Closed		- Bug is documented as fixed

------------------------------------------------------------------------------------------

Testing Vocab

Test Case
	A set of inputs and conditions and expected results
Test Suite
	A group of test cases related to each other (same functionality)
Test Strategy
	Document that sets the standard for the testing process
	Typically company wide - The same for every project
	Objectives
	Scopes
	High Level
Test Plan
	Document that tells us what to test and how and who will do it
	Project wide
	Features to be tested
	Testing techniques
	Test enviroments
	Schedule
	Low level (Specific)
Risk-Based Testing
	Testing principle that prioritizes testing features based on:
	Risk of failure
	The importance of the function to be tested
	Impact of failure

	Prioritize and emphasize the suitable tests during test execution
	Improved quality - all critical functions are testing

----------------------------------------------------------------------------------

Types of Testing
	White Box Testing
		Testing based on the knowledge of the internal code
		Applies mostly to low level unit tests
	Black Box Testing
		Testing an application without knowledge of how it works  
		Typically focuses on functionality
		Mimics how a user would test it
Functional Testing
	Testing to see if a piece of software does what it is supposed to do
	Given a set of inputs, there are expected outputs
	
	1. Unit Testing
		Testing of individual software components
		Down to a method, unless a method does a lot
	2. Integration Testing
		Testing done to expose deficiencies between code components
			working together
	3. System Testing
		Test a complete and integrated software application
		Front to back, start to finish, call all smaller parts
	4. Acceptance Testing
		The final complete piece of software is tested to make sure
			it is ready for deployment
		This is done by a human
		Ex, vissually, conceptually wrong
	
	  Unit Testing		- White Box
		|
		|
		V
	   Integration		- White/Black - Grey Box
		|
		|
		V
	  System Testing	- Black Box
		|
		|
		V
	   Acceptance		- Black Box

Non-functional Testing
	Testing for non-functional aspects of the software
		Usability Testing
		Performance
		Reliability
	Usability Testing
		Testing if the application is friendly for users to use
		Has to be done by a human
		Ex: Grey screen with small text could function properly,
			but it is unfriendly to use
	Reliability Testing
		Testing whether the software can perform failure-free operations
			for a specified length of time
		Feature Testing
			Test that a feature's operations are all executed properly
		Load Testing
			Software tends to perform better at first and degrade over time
		Regression Testing
			Make sure new bugs haven't been introduced with new code
	Performance Testing
		Testing the responsiveness, stability and efficiency of your application
		Load Testing
			Testing a system and evaluating its behaviors under heavy use
			Have 10,000 users use it simultaniously
			JMeter, can make as many requests as you tell it to
		Stress Testing
			Testing and evaluating a system's behavior when pushed beyond
				what it is designed to do
			Check pressure points
			Submit 10,000 orders at once
		Endurance Testing
			Testing to see if the application can process and work for a 
				prolonged period of time under heavy use
			Have 10,000 users use it for 5 days straight
		Spike Testing
			Testing conducted to see how the software deals with a sudden
				surge of use
			Having no users, then logging 10,000 in quickly
			Have many make many requests at once, after being idle

Regression Testing
	Incremental testing of software to ensure that new additions to the software
	do not break functionality
		Write new code, run old tests, write new tests
Testing Automation
	Using software to perform manual testing
	Tests are repeatable
	Cuts testing time doesn't significantly
	After hours testing
	Increase code coverage*
Positive Testing
	Testing to see thata certain procedure succeeds
	User enters valid data
Negative Testing
	Testing to see that a certain procedure fails
	User enters invalid data
	Passes if fails
Smoke Testing
	Running tests just to see if your application is even in a state to be tested
	Is internet connected?
	Can save time if you run them, fast, will know of you can run others


Test Driven Development (TDD)
	Develop tests (typically unit tests)
	Write code to make them pass

Behavior Driven Development (BDD)
	Expansion of TDD
	Develop failing acceptance tests and program to pass them
	Write user stories, turn them into tests, then write code to make tests pass
	We will be using Cucumber to accomplish this
	
Red/Green Testing
	Mantra used by TDD (And BDD) where you write that that fail (RED). Then
	you write code until they pass (GREEN). Then you can write more tests.
		Should be incremental, don't write all tests at once

Alpha Testing
	Testing an appplication as how an end user might use it
	Usually done by internal employees, have knowledge of the code
Beta Testing
	Releasing the software to a limited number of expected users,
	who have no connection to development


More Vocab:
Defect/Bug
	Software that doesn't behave as expected, often in a detrimental way
Severity
	How much does the functionality of a feature get compromised when it fails?
Priority
	How pressing is it that a defect be corrected?

High Serverity, Low Priority
	Unused feature breaks application, 1 admin who developed, delete bug, can access db
Low Priority, High Priority
	Design flaw, Facebook says Twitter





Pyramid	vs Ice Cream Cone

Manual UI		   /\
Automated UI		  /  \	Don't test functionality w UI tests, unit and int should
Automated Integration	 /    \
Automated Unit		/______\

Don't test functionality w UI tests, unit and int should
			________
			\      /
			 \    /
			  \  /
			   \/
Used to do ice cream cone, most stuff tested manually

-----------------------------------------------------------------------------------------

Selenium
	*A suite of tools* aimed at automation (used predominately for testing)
Some of these tools:
	Selenium Client API
		Support for writing Selenium in many languages
	Selenium Remote Control
		Server that allows for writing the web application tests in many languages
	Selenium Grid
		A server that can test using many machines running in parallel
	Selenium Webdriver*
		A serverless way to execute your tests. The heart of modern Selenium
		Starts a browser and controls it

	You need a different driver for each type of browser you plan to automate
	chromedriver.exe -> Google Chrome
	geckodriver.exe -> Mozilla Firefox

-----------------------------------------------------------------------------------------

POM	- Page Object Model
	Create a Java class whose fields represent elements in a webpage
	We use the POM to help organize our code and abstract away getting elements
	Makes code extebsible and easy to read

-----------------------------------------------------------------------------------------

TestNG	- Test Next Generation
	- A superset of JUnit
	- We can set priorities to easily determine the order in which our tests run
	- And the ability to run tests in parallel* 
		(one thread, but same priority, independent)


JUnit		TestNG
@BeforeClass	@BeforeSuite
@Before		@BeforeMethod
@Test		@Test
@After		@AfterMethod
@AfterClass	@AfterSuite

-----------------------------------------------------------------------------------------

Cucumber
	- A BDD Framework. Behavior Driven Development

Cucumber Feature File
	Feature: describe the feature or segment of functionality of your application
		 you are testing. High level description of the software feature
	Background: is used to provide content to our software
	Scenario: defined steps for our tests, uses Cucumber programming language: Gherkin
	Gherkin: a VERY HIGH LEVEL language, which is essentially English
		 It provides a structure for our code to implement. Gherkin will generate
		 the method signature for our tests. Called step implementations.

	Scenario:
		Given 	- Some set of preconditions
		When	- Some set of actions
		Then	- Some sort of test or observable outcome
		You can concatenate any of these with the AND keyword
		"given this when that and ... and ..."

To write a Cucumber BDD test

1. Write a feature file
2. Implement the step implementations created by the feature file
3. Put the step implementation and features into the test runner

Can outline all features of application in English before coding

-----------------------------------------------------------------------------------------

Protractor

- end to end testing - e2e
- e2e tesing automation framework
- **Designed specifically for Angular applications**
	- You can use Angular for non-Angular pages	
- conf.js
	- Selenium address
	- Location of your specs (tests)
- spec.js(.ts)
	- Your specs/tests

With Protractor you host a server for Selenium, in Java it was serverless

-----------------------------------------------------------------------------------------

Jasmine

Testing Framework for JavaScript
	- Protractor is a framework that utilizes the Jasmine framework

Structure of its tests:
	- describe	- Describe the test suite
	- it		- A specific test or spec
	- expect	- Creates an expectation
	- toBe		- Assertion

flaky tests

QC Mon: 2-3